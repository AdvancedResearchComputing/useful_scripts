#!/usr/bin/env bash

# Usage: ./shownodeusage.sh <nodename>

if [ $# -ne 1 ]; then
    echo "Usage: $0 <nodename>"
    exit 1
fi

NODE="$1"

{
    # 1) Print header (tab‐separated).  'column -t' will align later.
    printf "JobID\tUser\tElapsed\tTotal-CPUs\tTotal-Mem(GB)\tTotal-GPUs\tGPUs-IDX-on-this-node\n"

    # 2) For each job currently on $NODE, gather scontrol details once.
    for JOBID in $(squeue -h -w "$NODE" -o "%i"); do
        INFO=$(scontrol show job -d "$JOBID")

        # --- USERNAME ---
        USERNAME=$(echo "$INFO" \
            | grep -oP 'UserId=\K[^()]+' \
            || printf "UNKNOWN")

        # --- ELAPSED (RunTime) ---
        ELAPSED=$(echo "$INFO" \
            | grep -oP 'RunTime=\K[^ ]+' \
            || printf "N/A")

        # --- ALLOCTRES STRING ---
        TRES_ALLOC=$(echo "$INFO" \
            | grep -oP 'AllocTRES=\K[^ ]+' \
            || printf "-")

        if [ "$TRES_ALLOC" = "-" ]; then
            CPUS="-"
            MEM_GB="-"
            GPUS="-"
        else
            CPUS=$(echo "$TRES_ALLOC" \
                | awk -F, '{
                    for (i=1; i<=NF; i++) {
                        if ($i ~ /^cpu=/) {
                            sub(/^cpu=/, "", $i)
                            print $i
                            exit
                        }
                    }
                }')
            [ -z "$CPUS" ] && CPUS="-"

            GPUS=$(echo "$TRES_ALLOC" \
                | awk -F, '{
                    for (i=1; i<=NF; i++) {
                        if ($i ~ /^gres\/gpu=/) {
                            sub(/^gres\/gpu=/, "", $i)
                            print $i
                            exit
                        }
                    }
                }')
            [ -z "$GPUS" ] && GPUS="-"

            MEM_RAW=$(echo "$TRES_ALLOC" \
                | awk -F, '{
                    for (i=1; i<=NF; i++) {
                        if ($i ~ /^mem=/) {
                            sub(/^mem=/, "", $i)
                            print $i
                            exit
                        }
                    }
                }')
            if [ -n "$MEM_RAW" ]; then
                UNIT=${MEM_RAW: -1}
                NUM=${MEM_RAW%?}
                case "$UNIT" in
                    M)
                        MEM_GB=$(awk "BEGIN { printf \"%.1f\", $NUM/1024 }")
                        ;;
                    G)
                        MEM_GB=$(awk "BEGIN { printf \"%.1f\", $NUM }")
                        ;;
                    T)
                        MEM_GB=$(awk "BEGIN { printf \"%.1f\", $NUM * 1024 }")
                        ;;
                    *)
                        MEM_GB="$MEM_RAW"
                        ;;
                esac
            else
                MEM_GB="-"
            fi
        fi

        # --- GPU IDX for the requested node ---
        # Use bash to parse the scontrol output, expand bracketed node ranges
        # (preserving zero padding), and build a node->IDX(s) map.
        GPU_IDX="-"
        declare -A NODE_IDX_MAP=()

        while IFS= read -r ln; do
            # look for the Nodes= token (value ends at next whitespace)
            if [[ $ln =~ Nodes=([^[:space:]]+) ]]; then
                nodestr="${BASH_REMATCH[1]}"

                # collect all IDX values on this same line (there can be multiple)
                idxs_list=()
                # use awk to print each IDX value on its own line, then read them into idxs_list
                while IFS= read -r idx; do
                    [ -n "$idx" ] && idxs_list+=("$idx")
                done < <(
                    echo "$ln" \
                    | awk '{
                        s = $0
                        while (match(s, /\(IDX:([^)]*)\)/, m)) {
                            print m[1]
                            s = substr(s, RSTART + RLENGTH)
                        }
                    }'
                )

                # if no IDXs on this line, skip it
                [ ${#idxs_list[@]} -eq 0 ] && continue

                # join idxs with commas
                idxs_join=$(IFS=,; echo "${idxs_list[*]}")

                # expand bracketed nodes e.g. prefix[005-006,010]
                if [[ $nodestr =~ ^([A-Za-z0-9_.-]+)\[([^\]]+)\]$ ]]; then
                    prefix="${BASH_REMATCH[1]}"
                    inside="${BASH_REMATCH[2]}"
                    IFS=, read -r -a parts <<< "$inside"
                    for part in "${parts[@]}"; do
                        if [[ $part =~ ^([0-9]+)-([0-9]+)$ ]]; then
                            low=${BASH_REMATCH[1]}; high=${BASH_REMATCH[2]}
                            width=${#BASH_REMATCH[1]}
                            for ((n=low; n<=high; n++)); do
                                node=$(printf "%s%0*d" "$prefix" "$width" "$n")
                                if [ -z "${NODE_IDX_MAP[$node]}" ]; then
                                    NODE_IDX_MAP[$node]="$idxs_join"
                                else
                                    NODE_IDX_MAP[$node]="${NODE_IDX_MAP[$node]},$idxs_join"
                                fi
                            done
                        elif [[ $part =~ ^[0-9]+$ ]]; then
                            width=${#part}
                            node=$(printf "%s%0*d" "$prefix" "$width" "$part")
                            if [ -z "${NODE_IDX_MAP[$node]}" ]; then
                                NODE_IDX_MAP[$node]="$idxs_join"
                            else
                                NODE_IDX_MAP[$node]="${NODE_IDX_MAP[$node]},$idxs_join"
                            fi
                        else
                            # unexpected token; add literal (rare)
                            node="${prefix}[${part}]"
                            if [ -z "${NODE_IDX_MAP[$node]}" ]; then
                                NODE_IDX_MAP[$node]="$idxs_join"
                            else
                                NODE_IDX_MAP[$node]="${NODE_IDX_MAP[$node]},$idxs_join"
                            fi
                        fi
                    done
                else
                    # not bracketed: maybe a single name or comma-separated list
                    IFS=, read -r -a names <<< "$nodestr"
                    for node in "${names[@]}"; do
                        node="${node}"   # preserve literal
                        if [ -z "${NODE_IDX_MAP[$node]}" ]; then
                            NODE_IDX_MAP[$node]="$idxs_join"
                        else
                            NODE_IDX_MAP[$node]="${NODE_IDX_MAP[$node]},$idxs_join"
                        fi
                    done
                fi
            fi
        done <<< "$INFO"

        # lookup
        GPU_IDX="${NODE_IDX_MAP[$NODE]:-}"
        [ -z "$GPU_IDX" ] && GPU_IDX="-"



        # Print one row (tab‐separated)
        printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
            "$JOBID" "$USERNAME" "$ELAPSED" "$CPUS" "$MEM_GB" "$GPUS" "$GPU_IDX"
    done

} | column -t

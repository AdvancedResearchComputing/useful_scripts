#!/usr/bin/env bash

# Usage: ./shownodeusage.sh <nodename>

if [ $# -ne 1 ]; then
    echo "Usage: $0 <nodename>"
    exit 1
fi

NODE="$1"

{
    # 1) Print header (tab‐separated).  'column -t' will align later.
    printf "JobID\tUser\tElapsed\tTotal-CPUs\tTotal-Mem(GB)\tTotal-GPUs\tGPUs-IDX-on-this-node\n"

    # 2) For each job currently on $NODE, gather scontrol details once.
    for JOBID in $(squeue -h -w "$NODE" -o "%i"); do
        INFO=$(scontrol show job -d "$JOBID")

        # --- USERNAME ---
        USERNAME=$(echo "$INFO" \
            | grep -oP 'UserId=\K[^()]+' \
            || printf "UNKNOWN")

        # --- ELAPSED (RunTime) ---
        ELAPSED=$(echo "$INFO" \
            | grep -oP 'RunTime=\K[^ ]+' \
            || printf "N/A")

        # --- ALLOCTRES STRING ---
        TRES_ALLOC=$(echo "$INFO" \
            | grep -oP 'AllocTRES=\K[^ ]+' \
            || printf "-")

        if [ "$TRES_ALLOC" = "-" ]; then
            CPUS="-"
            MEM_GB="-"
            GPUS="-"
        else
            CPUS=$(echo "$TRES_ALLOC" \
                | awk -F, '{
                    for (i=1; i<=NF; i++) {
                        if ($i ~ /^cpu=/) {
                            sub(/^cpu=/, "", $i)
                            print $i
                            exit
                        }
                    }
                }')
            [ -z "$CPUS" ] && CPUS="-"

            GPUS=$(echo "$TRES_ALLOC" \
                | awk -F, '{
                    for (i=1; i<=NF; i++) {
                        if ($i ~ /^gres\/gpu=/) {
                            sub(/^gres\/gpu=/, "", $i)
                            print $i
                            exit
                        }
                    }
                }')
            [ -z "$GPUS" ] && GPUS="-"

            MEM_RAW=$(echo "$TRES_ALLOC" \
                | awk -F, '{
                    for (i=1; i<=NF; i++) {
                        if ($i ~ /^mem=/) {
                            sub(/^mem=/, "", $i)
                            print $i
                            exit
                        }
                    }
                }')
            if [ -n "$MEM_RAW" ]; then
                UNIT=${MEM_RAW: -1}
                NUM=${MEM_RAW%?}
                case "$UNIT" in
                    M)
                        MEM_GB=$(awk "BEGIN { printf \"%.1f\", $NUM/1024 }")
                        ;;
                    G)
                        MEM_GB=$(awk "BEGIN { printf \"%.1f\", $NUM }")
                        ;;
                    T)
                        MEM_GB=$(awk "BEGIN { printf \"%.1f\", $NUM * 1024 }")
                        ;;
                    *)
                        MEM_GB="$MEM_RAW"
                        ;;
                esac
            else
                MEM_GB="-"
            fi
        fi

        # --- GPU IDX for the requested node ---
        # Find the Nodes=... line that applies to $NODE (supports single names and bracket ranges),
        # then extract the IDX for that line.
        GPU_IDX=$(echo "$INFO" | awk -v NODE="$NODE" '
        BEGIN {
            # split NODE into prefix and numeric suffix (if present)
            if (match(NODE, /(.*?)([0-9]+)$/, m)) {
                pref = m[1]; num = m[2];
            } else { pref = NODE; num = ""; }
        }
        # consider any line that begins with optional space(s) then "Nodes="
        /^[ \t]*Nodes=/ {
            line = $0
            # get the Nodes= value
            if (match(line, /Nodes=([^ ]+)/, a)) {
                nodestr = a[1]
                ok = 0
                # exact match
                if (nodestr == NODE) ok = 1
                else {
                    # if nodestr is like prefix[...] check whether num is inside
                    if (match(nodestr, /^([A-Za-z0-9_.-]+)\[([^\]]+)\]/, b)) {
                        p = b[1]; inside = b[2]
                        if (p == pref) {
                            # split comma-separated parts inside brackets
                            n = split(inside, parts, ",")
                            for (i = 1; i <= n; i++) {
                                part = parts[i]
                                if (match(part, /^([0-9]+)-([0-9]+)$/, r)) {
                                    low = r[1] + 0; high = r[2] + 0
                                    if ((num + 0) >= low && (num + 0) <= high) { ok = 1; break }
                                } else if (part == num) { ok = 1; break }
                            }
                        }
                    }
                    # as a last resort, if the nodestr contains NODE as substring accept it
                    if (!ok && index(nodestr, NODE)) ok = 1
                }

                if (ok) {
                    if (match(line, /GRES=[^ ]*\(IDX:([^)]*)\)/, g)) {
                        print g[1]
                        exit
                    }
                }
            }
        }
        END { }
        ')

        [ -z "$GPU_IDX" ] && GPU_IDX="-"

        # Print one row (tab‐separated)
        printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
            "$JOBID" "$USERNAME" "$ELAPSED" "$CPUS" "$MEM_GB" "$GPUS" "$GPU_IDX"
    done

} | column -t
